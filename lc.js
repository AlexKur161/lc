1)Напишите функцию, которая может возвращать наименьшее значение массива или индекс этого значения.
 Второй параметр функции будет указывать, должно ли оно возвращать значение или индекс.

Предположим, что первым параметром всегда будет массив, содержащий как минимум 1 число
и не содержащий дубликатов. Предположим, что вторым параметром будет строка, содержащая
одно из двух значений: 'value' и 'index'.

ссылка на кату: https://www.codewars.com/kata/544a54fd18b8e06d240005c0/train/javascript

function min(arr, toReturn){

}
min([1,2,3,4,5], 'value') // => 1
min([1,2,3,4,5], 'index') // => 0

function min(arr, toReturn) {
  if(toReturn === 'index'){
   return arr.indexOf(Math.min(...arr));
   }
  if(toReturn === 'value'){
   return Math.min(...arr);
 }
 }


2)вам нужно создать функцию, которая при наличии триплета
 возвращает индекс числового элемента, расположенного между двумя другими элементами.
Входными данными для функции будет массив из трех различных чисел
Пояснение найти индекс числа между самым большим числом и самым маленьким 
ссылка на кату: https://www.codewars.com/kata/545a4c5a61aa4c6916000755/train/javascript
Например:
gimme([2, 3, 1]) => 0
2 - это число, которое находится в диапазоне от 1 до 3, а индекс 2 во входном массиве равен 0.
Еще один пример (просто чтобы убедиться, что это понятно).:
gimme([5, 10, 14]) => 1
10 - это число, которое находится в диапазоне от 5 до 14, а индекс 10 во входном массиве равен 1.

function gimme(triplet) {

}

gimme([2.1, 3.2, 1.4]) 0
gimme([-2, -3, -1]) 0
gimme([-5, -10, -14]) 1

function gimme(triplet) {
	return triplet.indexOf(triplet.find(item => {
  	return Math.max(...triplet) > item && Math.min(...triplet) < item
  }))
}




3)Учитывая массив / список [] целых чисел , постройте массив произведений того же размера,
 чтобы prod[i] был равен произведению всех элементов Arr[], кроме Arr[i].
 ссылка на кату: https://www.codewars.com/kata/5a905c2157c562994900009d/train/javascript

Записи
Размер массива/списка должен быть не менее 2 .
Числа в массиве/списке будут только положительными
Возможно повторение чисел в массиве/списке.
массив продуктов ({10,3,5,6,2}) возвращает ==> {180,600,360,300,900}
Объяснение:
Первый элемент 180 является произведением всех элементов массива, кроме первого элемента 10
Второй элемент 600 является произведением всех элементов массива, кроме второго элемента 3
Третий элемент 360 является произведением всех элементов массива, кроме третьего элемента 5
Четвертый элемент 300 является произведением всех элементов массива, за исключением четвертого элемента 6
Наконец, пятый элемент 900 является произведением всех элементов массива, за исключением пятого элемента 2

function productArray(numbers){

}

productArray([10,3,5,6,2]) /* 180,600,360,300,900 */

function productArray(numbers){
  let arr = [];
    numbers.forEach((item,i) => {
      arr.push(numbers.reduce((acc, item, index) => {
        return i !== index ? acc * item : acc
      },1))
    })
    return arr;
  }




4)Для целочисленных массивов,
 где второй массив является перетасованной копией первого массива,
  в котором отсутствует один элемент, найдите недостающий элемент.
  числа в массивах могут повторяться.

  ссылка на кату: https://www.codewars.com/kata/5a5915b8d39ec5aa18000030/train/javascript

  function findMissing(arr1, arr2) {

  }

  findMissing([6, 1, 3, 6, 8, 2], [3, 6, 6, 1, 2]) => 8


  function findMissing(arr1, arr2) {
    let missing;
      arr1.forEach(item => {
      let coincidence1 = arr1.filter(item2 => item2 === item).length
      let coincidence2 = arr2.filter(item3 => item3 === item).length
      coincidence1 !== coincidence2 ? missing = item : missing;
      })
      return missing;
    }


5)Существует массив с несколькими числами. Все числа равны, кроме одного. Попробуйте найти его!
ссылка на кату: https://www.codewars.com/kata/585d7d5adb20cf33cb000235/train/javascript
findUniq([ 1, 1, 1, 2, 1, 1 ]) === 2
findUniq([ 0, 0, 0.55, 0, 0 ]) === 0.55

Гарантируется, что массив содержит как минимум 3 числа.

function findUniq(arr) {
  ...ваш код
  }

findUniq([ 1, 1, 1, 2, 1, 1 ]) === 2
findUniq([ 0, 0, 0.55, 0, 0 ]) === 0.55
findUniq([ 2, 1, 1, 1, 1, 1 ]) === 2
findUniq([ 0, 0, 0, 0, 0.55 ]) === 0.55



function findUniq(arr) {
  return arr.filter((el, i, arr) => arr.indexOf(el) === arr.lastIndexOf(el))[0]
}